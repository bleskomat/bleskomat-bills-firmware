#include "util.h"

namespace {

	std::string generate_nonce() {
		std::ostringstream ss;
		uint32_t entropy = esp_random();
		// Random numbers generated by esp_random are probably sufficient.
		// But just to be safe let's append the current time in microseconds as well.
		auto extraEntropyFromTime = std::ceil((std::chrono::steady_clock::now().time_since_epoch().count() / 1000) % (UINT32_MAX / 10));
		entropy += extraEntropyFromTime;
		ss << entropy;
		return ss.str();
	}
}

namespace util {

	std::string createSignedUrl(const std::string t_baseUrl, const Lnurl::Query &t_query) {
		Lnurl::SignerConfig signerConfig = config::getLnurlSignerConfig();
		signerConfig.callbackUrl = t_baseUrl;
		Lnurl::Signer signer(signerConfig);
		return signer.create_url(t_query);
	}

	std::string createSignedLnurlWithdraw(const double &t_amount, const Lnurl::Query &customParams) {
		Lnurl::Signer signer(config::getLnurlSignerConfig());
		std::string nonce = "";
		bool hasReferencePhrase = customParams.count("r") > 0;
		if (hasReferencePhrase == false) {
			// Generate a random nonce only if the reference phrase is missing.
			nonce = generate_nonce();
		} else {
			// Must have a non-empty nonce.
			// Put "r" as a reminder that the reference phrase acts as our nonce.
			nonce = "r";
		}
		Lnurl::WithdrawParams params;
		std::string amount = doubleToStringWithPrecision(t_amount, config::getFiatPrecision());
		params.minWithdrawable = amount;
		params.maxWithdrawable = amount;
		params.defaultDescription = "";
		for (auto const &it : customParams) {
			params.custom[it.first] = it.second;
		}
		params.custom["f"] = config::get("fiatCurrency");
		return signer.create_url(params, nonce);
	}

	std::string lnurlEncode(const std::string &text) {
		return Lnurl::encode(text);
	}

	std::string generateRandomPhrase(const unsigned int numWords, const std::string delimiter) {
		std::string phrase = "";
		unsigned int num = 0;
		while (num++ < numWords) {
			unsigned int index = esp_random() % BIP39_WORDLIST_EN.size();
			std::string word = BIP39_WORDLIST_EN[index];
			phrase += word + delimiter;
		}
		phrase.pop_back();// Remove last delimiter.
		return phrase;
	}

	std::string toUpperCase(std::string s) {
		std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c){ return std::toupper(c); });
		return s;
	}

	std::vector<std::string> stringListToStringVector(const std::string &stringList, const char &delimiter) {
		std::vector<std::string> stringVector;
		if (stringList != "") {
			std::istringstream ss(stringList);
			std::string value;
			while (std::getline(ss, value, delimiter)) {
				stringVector.push_back(value);
			}
		}
		return stringVector;
	}

	std::vector<float> stringListToFloatVector(const std::string &stringList, const char &delimiter) {
		std::vector<float> floatVector;
		if (stringList != "") {
			std::istringstream ss(stringList);
			std::string value;
			while (std::getline(ss, value, delimiter)) {
				floatVector.push_back(std::atof(value.c_str()));
			}
		}
		return floatVector;
	}

	std::string floatVectorToStringList(const std::vector<float> floatVector, const char &delimiter) {
		std::ostringstream ss;
		for (int index = 0; index < floatVector.size(); index++) {
			ss << floatVector[index] << delimiter;
		}
		std::string stringList = ss.str();
		if (stringList != "") {
			stringList.pop_back();// Remove the last instance of delimiter.
		}
		return stringList;
	}

	std::string replaceFirstOccurrence(
		std::string& s,
		const std::string& toReplace,
		const std::string& replaceWith
	)
	{
		std::size_t pos = s.find(toReplace);
		if (pos == std::string::npos) return s;
		return s.replace(pos, toReplace.length(), replaceWith);
	}

	std::string urlEncode(const std::string &value) {
		std::ostringstream escaped;
		escaped.fill('0');
		escaped << std::hex;
		for (std::string::const_iterator i = value.begin(), n = value.end(); i != n; ++i) {
			std::string::value_type c = (*i);
			// Keep alphanumeric and other accepted characters intact
			if (isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
				escaped << c;
				continue;
			}
			// Any other characters are percent-encoded
			escaped << std::uppercase;
			escaped << '%' << std::setw(2) << int((unsigned char) c);
			escaped << std::nouppercase;
		}
		return escaped.str();
	}

	std::string doubleToStringWithPrecision(const double &value, const int &precision) {
		std::ostringstream out;
		out.precision(precision);
		out << std::fixed << value;
		return out.str();
	}
}
